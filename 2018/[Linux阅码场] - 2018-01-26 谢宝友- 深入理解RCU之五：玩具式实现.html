<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		谢宝友- 深入理解RCU之五：玩具式实现
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652663559&amp;idx=1&amp;sn=c12c91279a0d363f2932bc700aef454c&amp;chksm=810f299ab678a08c6757b2b3beda8759a514a05f2454e89eb5ecc4f4acc9ba39419466446c09&amp;scene=27#wechat_redirect&cpage=33' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">谢宝友: 深入理解RCU之五：玩具式实现</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                            <span id="copyright_logo" class="rich_media_meta rich_media_meta_text meta_tag_text">原创：</span>
                                                                                        <span class="rich_media_meta rich_media_meta_text">
                                                        谢宝友
                                                    </span>
                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux阅码场</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux阅码场</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxDev</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">专业的Linux技术社区和Linux操作系统学习平台，内容涉及Linux内核,Linux内存管理,Linux进程管理,Linux文件系统和IO,Linux性能调优,Linux设备驱动以及Linux虚拟化和云计算等各方各面.</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2018-01-26</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <section style="background-color: rgb(255, 255, 255);box-sizing: border-box;"><section class="Powered-by-XIUMI V5" style="box-sizing: border-box;" powered-by="xiumi.us"><section class="" style="margin-top: 10px;margin-bottom: 10px;box-sizing: border-box;"><section class="" style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(249, 110, 87);padding: 10px;box-sizing: border-box;"><section class="Powered-by-XIUMI V5" style="box-sizing: border-box;" powered-by="xiumi.us"><section class="" style="box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><p style="box-sizing: border-box;"><strong><span style="color: rgb(255, 76, 0);">本文简介</span></strong></p><p style="box-sizing: border-box;">本文介绍“玩具式”RCU实现。这些实现并不注重性能、实用性，也不能使用于生产环境中，而仅仅是为了清晰的传递RCU的概念。即便如此，要理解这些玩具式的实现，也需要对硬件、RCU概念有深入的理解。</p><p style="box-sizing: border-box;">&nbsp;</p><p style="box-sizing: border-box;"><strong><span style="color: rgb(255, 76, 0);">作者简介</span></strong></p><p style="box-sizing: border-box;">谢宝友，在编程一线工作已经有20年时间，其中接近10年时间工作于Linux操作系统。</p><p style="box-sizing: border-box;">同时，他也是《深入理解并行编程》一书的译者。该书作者Paul E.McKeney是IBM Linux中心领导者，Linux RCU Maintainer。《深入理解RCU》系列文章整理了Paul E.McKeney的相关著作，希望能帮助读者更深刻的理解Linux内核中非常难于理解的模块：RCU。</p><p style="box-sizing: border-box;">目前，他在专心编写Hot-Pot操作系统。并准备在2018年年中，开放这个操作系统的源代码，并且编写一本《Hot-Pot操作系统详解--迈向工业级操作系统的实现》来详细阐述这个操作系统。</p><p style="box-sizing: border-box;">&nbsp;&nbsp;&nbsp; 联系方式：</p><p style="box-sizing: border-box;">&nbsp;&nbsp;&nbsp; mail:scxby@163.com</p><p style="box-sizing: border-box;">&nbsp;&nbsp;&nbsp; 微信：linux-kernel</p><p style="box-sizing: border-box;"><br  /></p><p style="box-sizing: border-box;"><strong><span style="color: rgb(255, 76, 0);">本文前序：</span></strong></p><p style="box-sizing: border-box;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652662265&amp;idx=1&amp;sn=4e0ec525316720553666482ec4bd9756&amp;chksm=810f2f64b678a672f9573d0374786f5cb1acbb08fdfe3881fac6275145471ad5fc39aa4bb03e&amp;scene=21#wechat_redirect" target="_blank">谢宝友： 深入理解Linux RCU之一——从硬件说起</a><br  /></p><p style="box-sizing: border-box;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652662347&amp;idx=1&amp;sn=86273543da5e20f21351b29e0db92f79&amp;chksm=810f2cd6b678a5c00ea54f9f43f3fed663e32e960ebbae6613b4058c5fa27900fd98e2b74c5f&amp;scene=21#wechat_redirect" target="_blank">谢宝友：深入理解Linux RCU：从硬件说起之内存屏障</a><br  /></p><p style="box-sizing: border-box;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652662596&amp;idx=1&amp;sn=1d803eb8faa0dc3e276c38617d90a82d&amp;chksm=810f2dd9b678a4cf7dd9114b646f1ba338b7bb7d5f97e0c80c26353d109789f94cc795d1e4c9&amp;scene=21#wechat_redirect" target="_blank">谢宝友：深入理解RCU之三：概念</a><br  /></p><p style="box-sizing: border-box;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652662810&amp;idx=1&amp;sn=16c8c52aaeb93643d62bfc4297f77e56&amp;chksm=810f2a87b678a3910d1f5d638896345ae7201a0eaee75f54226dce3a805c6e9a41c3e07c01da&amp;scene=21#wechat_redirect" target="_blank">谢宝友：深入理解RCU之四：用法</a><br  /></p></section></section></section></section></section></section></section><p><span style="font-size: 12px;"></span></p><p><strong>&nbsp;</strong></p><p style="margin-top:8px;margin-bottom:4px;"><strong><span style="font-size:16px;line-height:115%;">1</span></strong><strong><span style="font-size:16px;line-height:115%;font-family:黑体;">、基于锁的</span></strong><strong><span style="font-size:16px;line-height:115%;">RCU</span></strong></p><p style="text-indent:27px;">也许最简单的RCU实现就是用锁了，如下图所示。在该实现中，rcu_read_lock()获取一把全局自旋锁，rcu_read_unlock()释放锁，而synchronize_rcu()获取自旋锁，随后将其释放。</p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">4&nbsp; }</p><p style="margin-left:28px;">5</p><p style="margin-left:28px;">6&nbsp; static&nbsp;void&nbsp; rcu_read_unlock(void)</p><p style="margin-left:28px;">7&nbsp; {</p><p style="margin-left:28px;">8&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">9&nbsp; }</p><p style="margin-left:28px;">10</p><p style="margin-left:28px;">11&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="margin-left:28px;">12&nbsp; {</p><p style="margin-left:28px;">13&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">14&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">15&nbsp; }</p><p style="margin-top:10px;margin-bottom:10px;"><strong><span style="font-size:16px;font-family:黑体;">基于锁的RCU实现</span></strong></p><p style="text-indent:27px;">因为synchronize_rcu()只有在获取锁（然后释放）以后才会返回，所以在所有之前发生的RCU读端临界区完成前，synchronize_rcu()是不会返回的，因此这符合RCU的语义，特别是存在担保方面的语义。</p><p style="text-indent:27px;">但是，在这样的实现中，一个读端临界区同时只能有一个RCU读者进入，这基本上可以说是和RCU的目的相反。而且，rcu_read_lock()和rcu_read_unlock()中的锁操作开销是极大的，读端的开销从Power5单核CPU上的100纳秒到64核系统上的17微秒不等。更糟的是，使用同一把锁使得rcu_read_lock()<span style="font-family:宋体;">，可能会使得系统形成自旋锁死锁</span>。这是因为：RCU的语义允许RCU读端嵌套。所以，在这样的实现中，RCU读端临界区不能嵌套。最后一点，原则上并发的RCU更新操作可以共享一个公共的优雅周期，但是该实现将优雅周期串行化了，因此无法共享优雅周期。</p><p style="text-indent:27px;">问题：这样的死锁情景会不会出现其他RCU实现中？</p><p style="text-indent:27px;"><span style="letter-spacing:.3px;">问题：为什么不直接用读写锁来实现这个RCU？</span></p><p style="text-indent:27px;">很难想象这种实现能用在任何一个产品中，但是这种实现有一点好处：可以用在几乎所有的用户态程序上。不仅如此，类似的使用每CPU锁或者读写锁的实现还曾经用于Linux 2.4内核中。</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">2</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、基于每线程锁的RCU</span></p><p style="text-indent:28px;"><span style="letter-spacing:-.3px;">下图显示了一种基于每线程锁的实现。</span><span style="letter-spacing:-.3px;">rcu_read_lock()</span><span style="letter-spacing:-.3px;">和</span><span style="letter-spacing:-.3px;">rcu_read_unlock()</span><span style="letter-spacing:-.3px;">分别获取和释放当前线程的锁。</span><span style="letter-spacing:-.3px;">synchronize_rcu()</span>函数按照次序逐一获取和释放每个线程的锁。这样，所有在synchronize_rcu()开始时就已经执行的RCU读端临界区，必须在synchronize_rcu()结束前返回。</p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;__get_thread_var(rcu_gp_lock));</p><p style="margin-left:28px;">4&nbsp; }</p><p style="margin-left:28px;">5</p><p style="margin-left:28px;">6&nbsp; static&nbsp;void&nbsp; rcu_read_unlock(void)</p><p style="margin-left:28px;">7&nbsp; {</p><p style="margin-left:28px;">8 &nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;__get_thread_var(rcu_gp_lock));</p><p style="margin-left:28px;">9&nbsp; }</p><p style="margin-left:28px;">10</p><p style="margin-left:28px;">11&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="margin-left:28px;">12&nbsp; {</p><p style="margin-left:28px;">13&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;t;</p><p style="margin-left:28px;">14</p><p style="margin-left:28px;">15&nbsp;&nbsp;&nbsp;&nbsp; for_each_running_thread(t)&nbsp; {</p><p style="margin-left:28px;">16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;per_thread(rcu_gp_lock,&nbsp;t));</p><p style="margin-left:28px;">17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;per_thread(rcu_gp_lock,&nbsp;t));</p><p style="margin-left:28px;">18&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">19&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">基于锁的每线程RCU实现</span></p><p style="text-indent:27px;">该实现的优点在于：允许并发的RCU读者，同时避免了使用单个全局锁可能造成的死锁。不仅如此，读端开销虽然高达大概140纳秒，但是不管CPU数目为多少，始终保持在140纳秒。不过，更新端的开销则在从Power5单核上的600纳秒到64核系统上的超过100微秒不等。</p><p style="text-indent:27px;">问题：如果在第15至18行看，先获取所有锁，然后再释放所有锁，这样是不是更清晰一点呢？</p><p style="text-indent:27px;">问题：该实现能够避免死锁吗？如果能，为什么能？如果不能，为什么不能？</p><p style="text-indent:27px;">本方法在某些情况下是很有效的，尤其是类似的方法曾在Linux 2.4内核中使用。</p><p style="text-indent:27px;">下面提到的基于计数的RCU实现，克服了基于锁实现的某些缺点。</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">3</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、基于计数的简单RCU实现</span></p><p style="margin-left:28px;">1&nbsp; atomic_t&nbsp;rcu_refcnt;</p><p style="margin-left:28px;">2</p><p style="margin-left:28px;">3&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="margin-left:28px;">4&nbsp; {</p><p style="margin-left:28px;">5&nbsp;&nbsp;&nbsp;&nbsp; atomic_inc(&amp;rcu_refcnt);</p><p style="margin-left:28px;">6&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">7&nbsp; }</p><p style="margin-left:28px;">8</p><p style="margin-left:28px;">9&nbsp; static&nbsp;void&nbsp; rcu_read_unlock(void)</p><p style="margin-left:28px;">10&nbsp; {</p><p style="margin-left:28px;">11&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">12&nbsp;&nbsp;&nbsp;&nbsp; atomic_dec(&amp;rcu_refcnt);</p><p style="margin-left:28px;">13&nbsp; }</p><p style="margin-left:28px;">14</p><p style="margin-left:28px;">15&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="margin-left:28px;">16&nbsp; {</p><p style="margin-left:28px;">17&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">18&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp;(atomic_read(&amp;rcu_refcnt)&nbsp;!=&nbsp; 0)&nbsp; {</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poll(NULL,&nbsp; 0,&nbsp;10);</p><p style="margin-left:28px;">20&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">21&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">22&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用单个全局引用计数的RCU实现</span></p><p style="text-indent:27px;">这是一种稍微复杂一点的RCU实现。本方法在第1行定义了一个全局引用计数rcu_refcnt。rcu_read_lock()原语自动增加计数，然后执行一个内存屏障，确保在原子自增之后才进入RCU读端临界区。同样，rcu_read_unlock()先执行一个内存屏障，划定RCU读端临界区的结束点，然后再原子自减计数。synchronize_rcu()原语不停自旋，等待引用计数的值变为0，语句前后用内存屏障保护正确的顺序。第19行的poll()只是纯粹的延时，从纯RCU语义的角度上看是可以省略的。等synchronize_rcu()返回后，所有之前发生的RCU读端临界区都已经完成了。</p><p style="text-indent:27px;">与基于锁的实现相比，我们欣喜地发现：这种实现可以让读者并发进入RCU读端临界区。与基于每线程锁的实现相比，我们又欣喜地发现：本节的实现可以让RCU读端临界区嵌套。另外，rcu_read_lock()原语不会进入死锁循环，因为它既不自旋也不阻塞。</p><p style="text-indent:27px;">问题：但是如果你在调用synchronize_rcu()时持有一把锁，然后又在RCU读端临界区中获取同一把锁，会发生什么呢？</p><p style="text-indent:27px;">当然<span style="letter-spacing:-.3px;">，这个实现还是存在一些严重的缺点。首先，</span><span style="letter-spacing:-.3px;">rcu_read_lock()</span><span style="letter-spacing:-.3px;">和</span><span style="letter-spacing:-.3px;">rcu_read_unlock()</span><span style="letter-spacing:-.3px;">中</span>的原子操作开销是非常大的，读端开销从Power5单核CPU上的100纳秒到64核系统上的40微秒不等。这意味着RCU读端临界区必须非常长，才能够满足现实世界中的读端并发请求。但是从另一方面来说，当没有读者时，优雅周期只有差不多40纳秒，这比Linux内核中的产品级实现要快上很多个数量级。</p><p style="text-indent:27px;">其次，如果存在多个并发的rcu_read_lock()和rcu_read_unlock()操作，因为出现大量高速缓冲未命中，对rcu_refcnt的内存访问竞争将会十分激烈。</p><p style="text-indent:27px;">以上这两个缺点极大地影响RCU的目标，即提供一种读端低开销的同步原语。</p><p style="text-indent:27px;">最后，在很长的读端临界区中的大量RCU读者甚至会让synchronize_rcu()无法完成，因为全局计数可能永远不为0。这会导致RCU更新端的饥饿，这一点在产品级应用里肯定是不可接受的。</p><p style="text-indent:27px;">问题：当synchronize_rcu()等待时间过长了以后，为什么不能简单地让rcu_read_lock()暂停一会儿呢？这种做法不能防止synchronize_rcu()饥饿吗？</p><p style="text-indent:27px;">通过上述内容，很难想象本节的实现可以在产品级应用中使用，虽然它比基于锁的实现更有这方面的潜力，比如，作为一种高负荷调试环境中的RCU实现。下面我们将介绍一种对写者更有利的引用计数RCU变体。</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">4</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、不会让更新者饥饿的引用计数RCU</span></p><p style="margin-left:28px;">1&nbsp; DEFINE_SPINLOCK(rcu_gp_lock);</p><p style="margin-left:28px;">2&nbsp; atomic_t&nbsp;rcu_refcnt[2];</p><p style="margin-left:28px;">3&nbsp; atomic_t&nbsp;rcu_idx;</p><p style="margin-left:28px;">4&nbsp; DEFINE_PER_THREAD(int,&nbsp; rcu_nesting);</p><p style="margin-left:28px;">5&nbsp; DEFINE_PER_THREAD(int,&nbsp; rcu_read_idx);</p><p style="margin-top:10px;margin-bottom:10px;"><span style="font-size:16px;font-family:黑体;">RCU</span><span style="font-size:16px;font-family:黑体;">全局引用计数对的数据定义</span></p><p style="text-indent:27px;">下图展示了一种RCU实现的读端原语，使用一对引用计数（rcu_refcnt[]），通过一个全局索引（rcu_idx）从这对计数中选出一个计数，一个每线程的嵌套计数rcu_nesting，一个每线程的全局索引快照（rcu_read_idx），以及一个全局锁（rcu_gp_lock），上图给出了上述定义。</p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">4&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;n;</p><p style="margin-left:28px;">5</p><p style="margin-left:28px;">6&nbsp;&nbsp;&nbsp;&nbsp; n&nbsp;=&nbsp; __get_thread_var(rcu_nesting);</p><p style="margin-left:28px;">7&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(n&nbsp; ==&nbsp; 0)&nbsp; {</p><p style="margin-left:28px;">8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i&nbsp;=&nbsp; atomic_read(&amp;rcu_idx);</p><p style="margin-left:28px;">9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_read_idx)&nbsp; =&nbsp; i;</p><p style="margin-left:28px;">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_inc(&amp;rcu_refcnt[i]);</p><p style="margin-left:28px;">11&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">12&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_nesting)&nbsp; =&nbsp;n&nbsp; +&nbsp; 1;</p><p style="margin-left:28px;">13&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">14&nbsp; }</p><p style="margin-left:28px;">15</p><p style="margin-left:28px;">16&nbsp; static&nbsp;void&nbsp; rcu_read_unlock(void)</p><p style="margin-left:28px;">17&nbsp; {</p><p style="margin-left:28px;">18&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;n;</p><p style="margin-left:28px;">20</p><p style="margin-left:28px;">21&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">22&nbsp;&nbsp;&nbsp;&nbsp; n&nbsp;=&nbsp; __get_thread_var(rcu_nesting);</p><p style="margin-left:28px;">23&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(n&nbsp; ==&nbsp; 1)&nbsp; {</p><p style="margin-left:28px;">24 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp; __get_thread_var(rcu_read_idx);</p><p style="margin-left:28px;">25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_dec(&amp;rcu_refcnt[i]);</p><p style="margin-left:28px;">26&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">27&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_nesting)&nbsp; =&nbsp;n&nbsp; -&nbsp; 1;</p><p style="margin-left:28px;">28&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用全局引用计数对的RCU读端原语</span></p><p style="text-indent:27px;">拥有两个元素的rcu_refcnt[]数组让更新者免于饥饿。这里的关键点是synchronize_rcu()只需要等待已存在的读者。如果在给定实例的synchronize_rcu()正在执行时，出现一个新的读者，那么synchronize_rcu()不需要等待那个新的读者。在任意时刻，当给定的读者通过通过rcu_read_lock()进入其RCU读端临界区时，它增加rcu_refcnt[]数组中由rcu_idx变量所代表下标的元素。当同一个读者通过rcu_read_unlock()退出其RCU读端临界区，它减去其增加的元素，忽略对rcu_idx值任何可能的后续更改。</p><p style="text-indent:27px;">这种安排意味着synchronize_rcu()可以通过修改rcu_idx的值来避免饥饿。假设rcu_idx的旧值为零，因此修改后的新值为1。在修改操作之后到达的新读者将增加rcu_idx[1]，而旧的读者先前递增的rcu_idx [0]将在它们退出RCU读端临界区时递减。这意味着rcu_idx[0]的值将不再增加，而是单调递减。这意味着所有synchronize_rcu()需要做的是等待rcu_refcnt[0]的值达到零。</p><p style="text-indent:27px;">有了背景，我们来好好看看实际的实现原语。</p><p style="text-indent:27px;"><span style="font-family:黑体;">实现</span>rcu_read_lock()原语自动增加由rcu_idx标出的rcu_refcnt[]成员的值，然后将索引保存在每线程变量rcu_read_idx中。rcu_read_unlock()原语自动减少对应的<span style="letter-spacing:-.1px;">rcu_read_lock()</span><span style="letter-spacing:-.1px;">增加的那个计数的值。不过，因为</span><span style="letter-spacing:-.1px;">rcu_idx</span><span style="letter-spacing:-.1px;">每个线程只能设置为</span><span style="letter-spacing:-.1px;">rcu_idx</span><span style="letter-spacing:-.1px;">设置一个值，所以还需要一些手段才能允许嵌套。方法是用每线程的</span><span style="letter-spacing:-.1px;">rcu_nesting</span><span style="letter-spacing:-.1px;">变量跟踪嵌套。</span></p><p style="text-indent:27px;">为了让这种方法能够工作，rcu_read_lock()函数的第6行获取了当前线程的rcu_nesting，如果第7行的检查发现当前处于最外层的rcu_read_lock()，那么第8至10行获取变量rcu_idx的当前值，将其存到当前线程的rcu_read_idx中，然后增加被rcu_idx选中的rcu_refcnt元素的值。第12行不管现在的rcu_nesting值是多少，直接对其加1。第13行执行一个内存屏障，确保RCU读端临界区不会在rcu_read_lock()之前开始。</p><p style="text-indent:27px;">同样，rcu_read_unlock()函数在第21行也执行一个内存屏障，确保RCU读端临界区不会在rcu_read_unlock()代码之后还未完成。第22行获取当前线程的rcu_nesting，如果<span style="letter-spacing:-.1px;">第23行的检查发现当前处于最外层的</span><span style="letter-spacing:-.1px;">rcu_read_unlock()</span><span style="letter-spacing:-.1px;">，那么第24至25行获取当前线程的</span><span style="letter-spacing:-.1px;">rcu_read_idx</span><span style="letter-spacing:-.1px;">（由最外层的</span><span style="letter-spacing:-.1px;">rcu_read_lock()</span><span style="letter-spacing:-.1px;">保存）并且原子减少被</span><span style="letter-spacing:-.1px;">rcu_read_idx</span><span style="letter-spacing:-.1px;">选择的</span><span style="letter-spacing:-.1px;">rcu_refcnt</span><span style="font-family:宋体;letter-spacing:-.1px;">元</span><span style="letter-spacing:-.1px;">素。无论当前嵌套了多少层，第27行都直接减少本线程的</span><span style="letter-spacing:-.1px;">rcu_nesting</span><span style="letter-spacing:-.1px;">值。</span></p><p style="margin-left:28px;">1&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">4</p><p style="margin-left:28px;">5&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">6&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">7&nbsp;&nbsp;&nbsp;&nbsp; i&nbsp;=&nbsp; atomic_read(&amp;rcu_idx);</p><p style="margin-left:28px;">8&nbsp;&nbsp;&nbsp;&nbsp; atomic_set(&amp;rcu_idx,&nbsp; !i);</p><p style="margin-left:28px;">9&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">10&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp;(atomic_read(&amp;rcu_refcnt[i])&nbsp;!=&nbsp; 0)&nbsp; {</p><p style="margin-left:28px;">11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poll(NULL,&nbsp; 0,&nbsp;10);</p><p style="margin-left:28px;">12&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">13&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">14&nbsp;&nbsp;&nbsp;&nbsp; atomic_set(&amp;rcu_idx,&nbsp; i);</p><p style="margin-left:28px;">15&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">16&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp;(atomic_read(&amp;rcu_refcnt[!i])&nbsp;!=&nbsp; 0)&nbsp; {</p><p style="margin-left:28px;">17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poll(NULL,&nbsp; 0,&nbsp;10);</p><p style="margin-left:28px;">18&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">20&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">21&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用全局引用计数对的RCU更新端原语</span></p><p style="text-indent:27px;">上图实现了对应的synchronize_rcu()。第6行和第19行获取并释放rcu_gp_lock，因为这样可以防止多于一个的并发synchronize_rcu()实例。第7至8行分别获取rcu_idx的值，并对其取反，这样后续的rcu_read_lock()实例将使用与之前的实例不同的rcu_idx值。然后第10至12行等待之前的由rcu_idx选出的元素变成0，第9行的内存屏障是为了保证对rcu_idx的检查不会被优化到对rcu_idx取反操作之前。第13至18行重复这一过程，第20行的内存屏障是为了保证所有后续的回收操作不会被优化到对rcu_refcnt的检查之前执行。</p><p style="text-indent:27px;">问题：为什么上图中，在获得自旋锁之前，synchronize_rcu()第5行还有一个内存屏障？</p><p style="text-indent:27px;">问题：为什么上图的计数要检查两次？难道检查一次还不够吗？</p><p style="text-indent:27px;">本节的实现避免了简单计数实现可能发生的更新端饥饿问题。</p><p style="text-indent:27px;"><span style="font-family:黑体;">讨<span style="letter-spacing:-.3px;">论</span></span><span style="letter-spacing:-.3px;">不过这种实现仍然存在一些严重问题。首先，</span><span style="letter-spacing:-.3px;">rcu_read_lock()</span><span style="letter-spacing:-.3px;">和</span><span style="letter-spacing:-.3px;">rcu_read_unlock()</span>中的原子操作开销很大。事实上，它们比上一个实现中的单个计数要复杂很多，读端原语的开销从Power5单核处理器上的150纳秒到64核处理器上的40微秒不等。更新端synchronize_rcu()原语的开销也变大了，从Power5单核CPU中的200纳秒到64核处理器中的40微秒不等。这意味着RCU读端临界区必须非常长，才能够满足现实世界的读端并发请求。</p><p style="text-indent:27px;">其次，如果存在很多并发的rcu_read_lock()和rcu_read_unlock()操作，那么对rcu_refcnt的内存访问竞争将会十分激烈，这将导致耗费巨大的高速缓存未命中。这一点进一步延长了提供并发读端访问所需要的RCU读端临界区持续时间。这两个缺点在很多情况下都影响了RCU的目标。</p><p style="text-indent:27px;">第三，需要检查rcu_idx两次这一点为更新操作增加了开销，尤其是线程数目很多时。</p><p style="text-indent:27px;">最后，尽管原则上并发的RCU更新可以共用一个公共优雅周期，但是本节的实现串行化了优雅周期，使得这种共享无法进行。</p><p style="text-indent:27px;">问题：既然原子自增和原子自减的开销巨大，为什么不第10行使用非原子自增，在第25行使用非原子自减呢？</p><p style="text-indent:27px;">尽管有这样那样的缺点，这种RCU的变体还是可以运用在小型的多核系统上，也许可以作为一种节省内存实现，用于维护与更复杂实现之间的API兼容性。但是，这种方法在CPU增多时可扩展性不佳。</p><p style="text-indent:27px;">另一种基于引用计数机制的RCU变体极大地改善了读端性能和可扩展性。</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">5</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、可扩展的基于计数RCU实现</span></p><p style="margin-left:28px;">1&nbsp; DEFINE_SPINLOCK(rcu_gp_lock);</p><p style="margin-left:28px;">2&nbsp; DEFINE_PER_THREAD(int&nbsp; [2],&nbsp;rcu_refcnt);</p><p style="margin-left:28px;">3&nbsp; atomic_t&nbsp;rcu_idx;</p><p style="margin-left:28px;">4&nbsp; DEFINE_PER_THREAD(int,&nbsp; rcu_nesting);</p><p style="margin-left:28px;">5&nbsp; DEFINE_PER_THREAD(int,&nbsp; rcu_read_idx);</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">RCU</span><span style="font-size:16px;font-family:黑体;">每线程引用计数对的数据定义</span></p><p style="text-indent:27px;">下图是一种RCU实现的读端原语，其中使用了每线程引用计数。本实现与前一个实现十分类似，唯一的区别在于rcu_refcnt成了一个每线程变量。使用这个两元素数组是为了防止读者导致写者饥饿。使用每线程rcu_refcnt[]数组的另一个好处是，rcu_read_lock()和rcu_read_unlock()原语不用再执行原子操作。</p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">4&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;n;</p><p style="margin-left:28px;">5</p><p style="margin-left:28px;">6&nbsp;&nbsp;&nbsp;&nbsp; n&nbsp;=&nbsp; __get_thread_var(rcu_nesting);</p><p style="margin-left:28px;">7&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(n&nbsp; ==&nbsp; 0)&nbsp; {</p><p style="margin-left:28px;">8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i&nbsp;=&nbsp; atomic_read(&amp;rcu_idx);</p><p style="margin-left:28px;">9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_read_idx)&nbsp; =&nbsp; i;</p><p style="margin-left:28px;">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_refcnt)[i]++;</p><p style="margin-left:28px;">11&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">12&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_nesting)&nbsp; =&nbsp;n&nbsp; +&nbsp; 1;</p><p style="margin-left:28px;">13&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">14&nbsp; }</p><p style="margin-left:28px;">15</p><p style="margin-left:28px;">16&nbsp; static&nbsp;void&nbsp; rcu_read_unlock(void)</p><p style="margin-left:28px;">17&nbsp; {</p><p style="margin-left:28px;">18&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;n;</p><p style="margin-left:28px;">20</p><p style="margin-left:28px;">21&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">22&nbsp;&nbsp;&nbsp;&nbsp; n&nbsp;=&nbsp; __get_thread_var(rcu_nesting);</p><p style="margin-left:28px;">23&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(n&nbsp; ==&nbsp; 1)&nbsp; {</p><p style="margin-left:28px;">24&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp; =&nbsp;__get_thread_var(rcu_read_idx);</p><p style="margin-left:28px;">25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_refcnt)[i]--;</p><p style="margin-left:28px;">26&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">27&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_nesting)&nbsp; =&nbsp;n&nbsp; -&nbsp; 1;</p><p style="margin-left:28px;">28&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用每线程引用计数对的RCU读端原语</span></p><p style="text-indent:27px;">问题：别忽悠了！我在rcu_read_lock()里看见atomic_read()原语了！为什么你想假装rcu_read_lock()里没有原子操作？</p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp;flip_counter_and_wait(int&nbsp; i)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;t;</p><p style="margin-left:28px;">4</p><p style="margin-left:28px;">5&nbsp;&nbsp;&nbsp;&nbsp; atomic_set(&amp;rcu_idx,&nbsp; !i);</p><p style="margin-left:28px;">6&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">7&nbsp;&nbsp;&nbsp;&nbsp; for_each_thread(t)&nbsp; {</p><p style="margin-left:28px;">8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp;(per_thread(rcu_refcnt,&nbsp;t)[i]&nbsp; !=&nbsp; 0)&nbsp; {</p><p style="margin-left:28px;">9 &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; poll(NULL,&nbsp; 0,&nbsp;10);</p><p style="margin-left:28px;">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">11&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">12&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">13&nbsp; }</p><p style="margin-left:28px;">14</p><p style="margin-left:28px;">15&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="margin-left:28px;">16&nbsp; {</p><p style="margin-left:28px;">17&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">18</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">20&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">21&nbsp;&nbsp;&nbsp;&nbsp; i&nbsp;=&nbsp; atomic_read(&amp;rcu_idx);</p><p style="margin-left:28px;">22&nbsp;&nbsp;&nbsp;&nbsp; flip_counter_and_wait(i);</p><p style="margin-left:28px;">23&nbsp;&nbsp;&nbsp;&nbsp; flip_counter_and_wait(!i);</p><p style="margin-left:28px;">24&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">25&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">26&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用每线程引用计数对的RCU更新端原语</span></p><p style="text-indent:27px;">下图<span style="letter-spacing:-.1px;">是</span><span style="letter-spacing:-.1px;">synchronize_rcu()</span><span style="letter-spacing:-.1px;">的实现，还有一个辅助函数</span><span style="letter-spacing:-.1px;">flip_counter_ </span>and_wait()。synchronize_rcu()函数和前一个实现基本一样，除了原来的重复检查计数过程被替换成了第22至23行的辅助函数。</p><p style="text-indent:27px;">新的flip_counter_and_wait()函数在第5行更新rcu_idx变量，第6行执行内存屏障，然后第7至11行循环检查每个线程对应的rcu_refcnt元素，等待该值变为0。一旦所有元素都变为0，第12行执行另一个内存屏障，然后返回。</p><p style="text-indent:27px;">本<span style="letter-spacing:.3px;">RCU</span><span style="letter-spacing:.3px;">实现对软件环境有所要求，（1）能够声明每线程变量，（2）每个线程都可以访问其他线程的每线程变量，（3）能够遍历所有线程。绝大多数软件环境都满足上述要求，但是通常对线程数的上限有所限制。更复杂的实现可以避开这种限制，比如，使用可扩展的哈希表。这种实现能够动态地跟踪线程，比如，在线程第一次调用</span><span style="letter-spacing:.3px;">rcu_read_lock()</span><span style="letter-spacing:.3px;">时将线程加入哈希表。</span></p><p style="text-indent:27px;">问题：好极了，如果我有<em>N</em>个线程，那么我要等待2<em>N</em>*10毫秒（每个flip_counter_and_wait()调用消耗的时间，假设我们每个线程只等待一次）。我们难道不能让优雅周期再快一点完成吗？</p><p style="text-indent:27px;">不过本实现还有一些缺点。首先，需要检查rcu_idx两次，这为更新端带来一些开销，特别是线程数很多时。</p><p style="text-indent:27px;">其次，synchronize_rcu()必须检查的变量数随着线程增多而线性增长，这给线程数很多的应用程序带来一定的开销。</p><p style="text-indent:27px;">第三，和之前一样，虽然原则上并发的RCU更新可以共用一个公共优雅周期，但是本节的实现串行化了优雅周期，使得这种共享无法进行。</p><p style="text-indent:27px;">最<span style="letter-spacing:.5px;">后，本节曾经提到的软件环境需求，在某些环境下每线程变量和遍历线程可能存在问题。</span></p><p style="text-indent:27px;">读端原语的扩展性非常好，不管是在单核系统还是64核系统都只需要115纳秒左右。Synchronize_rcu()原语的扩展性不佳，开销在单核Power5系统上的1微秒到64核系统上的200微秒不等。总体来说，本节的方法可以算是一种初级的产品级用户态RCU实现了。</p><p style="text-indent:27px;">下面介绍一种能够让并发的RCU更新更有效的算法。</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">6</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、可扩展的基于计数RCU实现，可以共享优雅周期</span></p><p style="margin-left:28px;">1&nbsp; DEFINE_SPINLOCK(rcu_gp_lock);</p><p style="margin-left:28px;">2&nbsp; DEFINE_PER_THREAD(int&nbsp; [2],&nbsp;rcu_refcnt);</p><p style="margin-left:28px;">3&nbsp; long&nbsp;rcu_idx;</p><p style="margin-left:28px;">4&nbsp; DEFINE_PER_THREAD(int,&nbsp; rcu_nesting);</p><p style="margin-left:28px;">5&nbsp; DEFINE_PER_THREAD(int,&nbsp; rcu_read_idx);</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用每线程引用计数对和共享更新数据的数据定义</span></p><p style="text-indent:27px;">下图是一种使用每线程引用计数RCU实现的读端原语，但是该实现允许更新端共享优雅周期。本节的实现和前面的实现唯一的区别是，rcu_idx现在是一个long型整数，可以自由增长，所以第8行用了一个掩码屏蔽了最低位。我们还将atomic_read()和atomic_set()改成了ACCESS_ONCE()。上图中的数据定义和前例也很相似，只是rcu_idx现在是long类型而非之前的atomic_t类型。</p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">4&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;n;</p><p style="margin-left:28px;">5</p><p style="margin-left:28px;">6&nbsp;&nbsp;&nbsp;&nbsp; n&nbsp;=&nbsp; __get_thread_var(rcu_nesting);</p><p style="margin-left:28px;">7&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(n&nbsp; ==&nbsp; 0)&nbsp; {</p><p style="margin-left:28px;">8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i&nbsp;=&nbsp; ACCESS_ONCE(rcu_idx)&nbsp; &amp;&nbsp;0x1;</p><p style="margin-left:28px;">9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_read_idx)&nbsp; =&nbsp; i;</p><p style="margin-left:28px;">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_refcnt)[i]++;</p><p style="margin-left:28px;">11&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">12&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_nesting)&nbsp; =&nbsp;n&nbsp; +&nbsp; 1;</p><p style="margin-left:28px;">13&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">14&nbsp; }</p><p style="margin-left:28px;">15</p><p style="margin-left:28px;">16&nbsp; static&nbsp;void&nbsp; rcu_read_unlock(void)</p><p style="margin-left:28px;">17&nbsp; {</p><p style="margin-left:28px;">18&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;n;</p><p style="margin-left:28px;">20</p><p style="margin-left:28px;">21&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">22&nbsp;&nbsp;&nbsp;&nbsp; n&nbsp;=&nbsp; __get_thread_var(rcu_nesting);</p><p style="margin-left:28px;">23&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(n&nbsp; ==&nbsp; 1)&nbsp; {</p><p style="margin-left:28px;">24 &nbsp;&nbsp;&nbsp;&nbsp; i&nbsp; =&nbsp;__get_thread_var(rcu_read_idx);</p><p style="margin-left:28px;">25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_refcnt)[i]--;</p><p style="margin-left:28px;">26&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">27&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_nesting)&nbsp; =&nbsp;n&nbsp; -&nbsp; 1;</p><p style="margin-left:28px;">28&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用每线程引用计数对和共享更新数据的RCU读端原语</span></p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp;flip_counter_and_wait(int&nbsp; ctr)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;i;</p><p style="margin-left:28px;">4&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;t;</p><p style="margin-left:28px;">5</p><p style="margin-left:28px;">6&nbsp;&nbsp;&nbsp;&nbsp; ACCESS_ONCE(rcu_idx)&nbsp; =&nbsp;ctr&nbsp; +&nbsp; 1;</p><p style="margin-left:28px;">7&nbsp;&nbsp;&nbsp;&nbsp; i&nbsp;=&nbsp; ctr&nbsp; &amp;&nbsp;0x1;</p><p style="margin-left:28px;">8&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">9&nbsp;&nbsp;&nbsp;&nbsp; for_each_thread(t)&nbsp; {</p><p style="margin-left:28px;">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp;(per_thread(rcu_refcnt,&nbsp;t)[i]&nbsp; !=&nbsp; 0)&nbsp;</p><p style="text-indent:90px;">{</p><p style="margin-left:28px;">11 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; poll(NULL,&nbsp; 0,&nbsp;10);</p><p style="margin-left:28px;">12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">13&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">14&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">15&nbsp; }</p><p style="margin-left:28px;">16</p><p style="margin-left:28px;">17&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="margin-left:28px;">18&nbsp; {</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;ctr;</p><p style="margin-left:28px;">20&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;oldctr;</p><p style="margin-left:28px;">21</p><p style="margin-left:28px;">22&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">23&nbsp;&nbsp;&nbsp;&nbsp; oldctr&nbsp;=&nbsp; ACCESS_ONCE(rcu_idx);</p><p style="margin-left:28px;">24&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">25&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">26&nbsp;&nbsp;&nbsp;&nbsp; ctr&nbsp;=&nbsp; ACCESS_ONCE(rcu_idx);</p><p style="margin-left:28px;">27&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(ctr&nbsp; -&nbsp; oldctr&nbsp;&gt;=&nbsp; 3)&nbsp; {</p><p style="margin-left:28px;">28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p><p style="margin-left:28px;">31&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">32&nbsp;&nbsp;&nbsp;&nbsp; flip_counter_and_wait(ctr);</p><p style="margin-left:28px;">33&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;(ctr&nbsp; -&nbsp; oldctr&nbsp;&lt;&nbsp; 2)</p><p style="margin-left:28px;">34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flip_counter_and_wait(ctr&nbsp; +&nbsp; 1);</p><p style="margin-left:28px;">35&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">36&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">37&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用每线程引用计数对的RCU共享更新端原语</span></p><p style="text-indent:27px;">上图<span style="letter-spacing:-.3px;">是</span><span style="letter-spacing:-.3px;">synchronize_rcu()</span><span style="letter-spacing:-.3px;">及其辅助函数</span><span style="letter-spacing:-.3px;">flip_counter_and_wait()</span>的实现。flip_counter_and_wait()的变化在于：</p><p style="text-indent:27px;">1．第6行使用ACCESS_ONCE()代替了atomic_set()，用自增替代取反。</p><p style="text-indent:27px;">2．新增了第7行，将计数的最低位掩去。</p><p style="text-indent:27px;">synchronize_rcu()的区别要多一些：</p><p style="text-indent:27px;">1．新增了一个局部变量oldctr，存储第23行的获取每线程锁之前的rcu_idx值。</p><p style="text-indent:27px;">2．第26行用ACCESS_ONCE()代替atomic_read()。</p><p style="text-indent:27px;">3．第27至30行检查在锁已获取时，其他线程此时是否在循环检查3个以上的计数，如果是，释放锁，执行一个内存屏障然后返回。在本例中，有两个线程在等待计数变为0，所以其他的线程已经做了所有必做的工作。</p><p style="text-indent:27px;">4．在第33至34行，在锁已被获取时，如果当前检查计数是否为0的线程不足2个，那么flip_counter_and_wait()会被调用两次。另一方面，如果有两个线程，另一个线程已经完成了对计数的检查，那么只需再有一个就可以。</p><p style="text-indent:27px;">在本方法中，如果有任意多个线程并发调用synchronize_rcu()，一个线程对应一个CPU，那么最多只有3个线程在等待计数变为0。</p><p style="text-indent:27px;">尽管有这些改进，本节的RCU实现仍然存在一些缺点。首先，和上一节一样，需要检查rcu_idx两次为更新端带来开销，尤其是线程很多时。</p><p style="text-indent:27px;">其次，本实现需要每CPU变量和遍历所有线程的能力，这在某些软件环境可能是有问题的。</p><p style="text-indent:27px;">最后，在32位机器上，由于rcu_idx溢出而导致需要做一些额外的检查。</p><p style="text-indent:27px;">本实现的读端原语扩展性极佳，不管CPU数为多少，开销大概为115纳秒。synchronize_rcu()原语的开销仍然昂贵，从1微秒到15微秒不等。然而这比前面的200微秒的开销已经好多了。所以，尽管存在这些缺点，本节的RCU实现已经可以在真实世界中的产品中使用了。</p><p style="text-indent:27px;">问题：所有这些玩具式的RCU实现都要么在rcu_read_lock()和rcu_read_ <span style="letter-spacing:-.1px;">unlock()</span><span style="letter-spacing:-.1px;">中使用了原子操作，要么让</span><span style="letter-spacing:-.1px;">synchronize_rcu()</span><span style="letter-spacing:-.1px;">的开销与线程数线性增长。那么究竟在哪种环境下，RCU的实现既可以让上述三个原语的实现简单，又能拥有</span><span style="letter-spacing:-.1px;">O(1)</span><span style="letter-spacing:-.1px;">的开销和延迟呢？</span></p><p style="text-indent:27px;">重新审视代码，我们看到了对一个全局变量的访问和对不超过4个每线程变量的访问。考虑到在POSIX线程中访问每线程变量的开销相对较高，我们可以将三个每线程变量放进单个结构体中，让rcu_read_lock()和rcu_read_unlock()用单个每线程变量存储类来访问各自的每线程变量。</p><p style="text-indent:27px;">但是，下面将会介绍一种更好的办法，可以减少访问每线程变量的次数到一次。</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">7</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、基于自由增长计数的RCU</span></p><p style="margin-left:28px;">1&nbsp; DEFINE_SPINLOCK(rcu_gp_lock);</p><p style="margin-left:28px;">2&nbsp; long&nbsp;rcu_gp_ctr&nbsp; =&nbsp; 0;</p><p style="margin-left:28px;">3&nbsp; DEFINE_PER_THREAD(long,&nbsp; rcu_reader_gp);</p><p style="margin-left:28px;">4&nbsp; DEFINE_PER_THREAD(long,&nbsp; rcu_reader_gp_snap);</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用自由增长计数的数据定义</span></p><p style="text-indent:27px;">下图是一种基于单个全局free-running计数的RCU实现，该计数只对偶数值进行计数，相关的数据定义见上图。rcu_read_lock()的实现极其简单。第3行向全局free-running变量rcu_gp_ctr加1，将相加后的奇数值存储在每线程变量rcu_reader_gp中。第4行执行一个内存屏障，防止后续的RCU读端临界区内容“泄漏”。</p><p style="margin-left:28px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="margin-left:28px;">2&nbsp; {</p><p style="margin-left:28px;">3&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_reader_gp)&nbsp; =&nbsp;rcu_gp_ctr&nbsp; +&nbsp; 1;</p><p style="margin-left:28px;">4&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">5&nbsp; }</p><p style="margin-left:28px;">6</p><p style="margin-left:28px;">7&nbsp; static&nbsp;void&nbsp; rcu_read_unlock(void)</p><p style="margin-left:28px;">8&nbsp; {</p><p style="margin-left:28px;">9&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">10&nbsp;&nbsp;&nbsp;&nbsp; __get_thread_var(rcu_reader_gp)&nbsp; =&nbsp;rcu_gp_ctr;</p><p style="margin-left:28px;">11&nbsp; }</p><p style="margin-left:28px;">12</p><p style="margin-left:28px;">13&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="margin-left:28px;">14&nbsp; {</p><p style="margin-left:28px;">15&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;t;</p><p style="margin-left:28px;">16</p><p style="margin-left:28px;">17&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">18&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">19&nbsp;&nbsp;&nbsp;&nbsp; rcu_gp_ctr&nbsp;+=&nbsp; 2;</p><p style="margin-left:28px;">20&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">21&nbsp;&nbsp;&nbsp;&nbsp; for_each_thread(t)&nbsp; {</p><p style="margin-left:28px;">22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp;((per_thread(rcu_reader_gp,&nbsp;t)&nbsp; &amp;&nbsp; 0x1)&nbsp;&amp;&amp;</p><p style="margin-left:28px;">23 ((per_thread(rcu_reader_gp,&nbsp; t)&nbsp; -</p><p style="margin-left:28px;">24 &nbsp;&nbsp;&nbsp;&nbsp; rcu_gp_ctr)&nbsp; &lt;&nbsp;0))&nbsp; {</p><p style="margin-left:28px;">25 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; poll(NULL,&nbsp; 0,&nbsp;10);</p><p style="margin-left:28px;">26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">27&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="margin-left:28px;">28&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="margin-left:28px;">29&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="margin-left:28px;">30&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用自由增长计数的RCU实现</span></p><p style="text-indent:27px;">rcu_read_unlock()实现也很类似。第9行执行一个内存屏障，防止前一个RCU读端临界区“泄漏”。第10行将全局变量rcu_gp_ctr的值复制给每线程变量rcu_reader_gp，将此每线程变量的值变为偶数值，这样当前并发的synchronize_rcu()实例就知道忽略该每线程变量了。</p><p style="text-indent:27px;">问题：如果任何偶数值都可以让synchronize_rcu()忽略对应的任务，那么第10行为什么不直接给rcu_reader_gp赋值为0？</p><p style="text-indent:27px;">synchronize_rcu()会等待所有线程的rcu_reader_gp变量变为偶数值。但是，因为synchronize_rcu()只需要等待“在调用synchronize_rcu()之前就已存在的”RCU读端临界区，所以完全可以有更好的方法。第17行执行一个内存屏障，防止之前操纵的受RCU保护的数据结构被乱序（由编译器或者是CPU）放到第17行之后执行。为了防止多个synchronize_rcu()实例并发执行，第18行获取rcu_gp_lock锁（第28释放锁）。然后第19行给全局变量rcu_gp_ctr加2。回忆一下，rcu_reader_gp的值为偶数的线程不在RCU读端临界区里，所以第21至27行扫描rcu_reader_gp的值，直到所有值要么是偶数（第22行），要么比全局变量rcu_gp_ctr的值大（第23至24行）。第25行阻塞一小段时间，等待一个之前已经存在的RCU读端临界区退出，如果对优雅周期的延迟很敏感的话，也可以用自旋锁来代替。最后，第29行的内存屏障保证所有后续的销毁工作不会被乱序到循环之前进行。</p><p style="text-indent:27px;">问题：为什么需要第17和第29行的内存屏障？难道第18行和第28行的锁原语自带的内存屏障还不够吗？</p><p style="text-indent:27px;">本节方法的读端性能非常好，不管CPU数目多少，带来的开销大概是63纳秒。更新端的开销稍大，从Power5单核的500纳秒到64核的超过100微秒不等。</p><p style="text-indent:27px;">这个实现除了刚才提到的更新端的开销较大以外，还有一些严重缺点。首先，该实现不允许RCU读端临界区嵌套。其次如果读者在第3行获取rcu_gp_ctr之后，存储到rcu_reader_gp之前被抢占，并且如果rcu_gp_ctr计数的值增长到最大值的一半以上，但没有达到最大值时，那么synchronize_rcu()将会忽略后续的RCU读端临界区。第三也是最后一点，本实现需要软件环境支持每线程变量和对所有线程遍历。</p><p style="text-indent:27px;">问题：第3行的读者被抢占问题是一个真实问题吗？换句话说，这种导致问题的事件序列可能发生吗？如果不能，为什么不能？如果能，事件序列是什么样的，我们该怎样处理这个问题？</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">8</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、基于自由增长计数的可嵌套RCU</span></p><p style="text-indent:24px;line-height:17px;">1&nbsp;DEFINE_SPINLOCK(rcu_gp_lock);</p><p style="text-indent:24px;line-height:17px;">2&nbsp; #define&nbsp; RCU_GP_CTR_SHIFT&nbsp; 7</p><p style="text-indent:24px;line-height:17px;">3&nbsp; #define&nbsp; RCU_GP_CTR_BOTTOM_BIT&nbsp; (1&nbsp;&lt;&lt;</p><p style="text-indent:24px;line-height:17px;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RCU_GP_CTR_SHIFT)</p><p style="text-indent:24px;line-height:17px;">4&nbsp; #define&nbsp; RCU_GP_CTR_NEST_MASK&nbsp;</p><p style="text-indent:24px;line-height:17px;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(RCU_GP_CTR_BOTTOM_BIT&nbsp; -&nbsp; 1)</p><p style="text-indent:24px;line-height:17px;">5&nbsp; long&nbsp; rcu_gp_ctr&nbsp;=&nbsp; 0;</p><p style="text-indent:24px;line-height:17px;">6&nbsp;DEFINE_PER_THREAD(long,&nbsp;rcu_reader_gp);</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">基于自由增长计数的可嵌套RCU的数据定义</span></p><p style="text-indent:27px;">下图是一种基于单个全局free-running计数的RCU实现，但是允许RCU读端临界区的嵌套。这种嵌套能力是通过让全局变量rcu_gp_ctr的低位记录嵌套次数实现的，定义在上图中。该方法保留低位来记录嵌套深度。为了做到这一点，定义了两个宏，RCU_GP_CTR_NEST_MASK和RCU_GP_CTR_BOTTOM_BIT。两个宏之间的关系是：RCU_GP_CTR_NEST_MASK=RCU_GP_ CTR_BOTTOM_BIT - 1。RCU_GP_CTR_BOTTOM_BIT宏是用于记录嵌套那一位之前的一位，RCU_GP_CTR_NEST_MASK<span style="font-family:宋体;">宏</span>则包含rcu_gp_ctr中所有用于记录嵌套的位。显然，这两个宏必须保留足够多的位来记录允许的最大RCU读端临界区嵌套深度，在本实现中保留了7位，这样，允许最大RCU读端临界区嵌套深度为127，这足够绝大多数应用使用。</p><p style="margin-top:10px;text-indent:24px;line-height:17px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="text-indent:24px;line-height:17px;">2&nbsp; {</p><p style="text-indent:24px;line-height:17px;">3&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp; tmp;</p><p style="text-indent:24px;line-height:17px;">4&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp; *rrgp;</p><p style="text-indent:24px;line-height:17px;">5</p><p style="text-indent:24px;line-height:17px;">6&nbsp;&nbsp;&nbsp;&nbsp; rrgp&nbsp; =&nbsp;&amp;__get_thread_var(rcu_reader_gp);</p><p style="text-indent:24px;line-height:17px;">7&nbsp;&nbsp;&nbsp;&nbsp; tmp&nbsp; =&nbsp;*rrgp;</p><p style="text-indent:24px;line-height:17px;">8&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp; ((tmp&nbsp;&amp;&nbsp; RCU_GP_CTR_NEST_MASK)&nbsp; ==&nbsp; 0)</p><p style="text-indent:24px;line-height:17px;">9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp; =&nbsp; rcu_gp_ctr;</p><p style="text-indent:24px;line-height:17px;">10&nbsp;&nbsp;&nbsp;&nbsp; tmp++;</p><p style="text-indent:24px;line-height:17px;">11&nbsp;&nbsp;&nbsp;&nbsp;*rrgp&nbsp; =&nbsp; tmp;</p><p style="text-indent:24px;line-height:17px;">12&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">13&nbsp; }</p><p style="text-indent:24px;line-height:17px;">14</p><p style="text-indent:24px;line-height:17px;">15&nbsp; static&nbsp; void&nbsp;rcu_read_unlock(void)</p><p style="text-indent:24px;line-height:17px;">16&nbsp; {</p><p style="text-indent:24px;line-height:17px;">17&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp; tmp;</p><p style="text-indent:24px;line-height:17px;">18</p><p style="text-indent:24px;line-height:17px;">19&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">20&nbsp;&nbsp;&nbsp;&nbsp;__get_thread_var(rcu_reader_gp)--;</p><p style="text-indent:24px;line-height:17px;">21&nbsp; }</p><p style="text-indent:24px;line-height:17px;">22</p><p style="text-indent:24px;line-height:17px;">23&nbsp; void&nbsp; synchronize_rcu(void)</p><p style="text-indent:24px;line-height:17px;">24&nbsp; {</p><p style="text-indent:24px;line-height:17px;">25&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; t;</p><p style="text-indent:24px;line-height:17px;">26</p><p style="text-indent:24px;line-height:17px;">27&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">28&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;rcu_gp_lock);</p><p style="text-indent:24px;line-height:17px;">29&nbsp;&nbsp;&nbsp;&nbsp; rcu_gp_ctr&nbsp; +=&nbsp;RCU_GP_CTR_BOTTOM_BIT;</p><p style="text-indent:24px;line-height:17px;">30&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">31&nbsp;&nbsp;&nbsp;&nbsp;for_each_thread(t)&nbsp; {</p><p style="text-indent:24px;line-height:17px;">32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp; (rcu_gp_ongoing(t)&nbsp; &amp;&amp;</p><p style="text-indent:24px;line-height:17px;">33 &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((per_thread(rcu_reader_gp,&nbsp; t)&nbsp; -</p><p style="text-indent:24px;line-height:17px;">34 &nbsp; &nbsp;&nbsp;&nbsp; rcu_gp_ctr)&nbsp;&lt;&nbsp; 0))&nbsp; {</p><p style="text-indent:24px;line-height:17px;">35 &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; poll(NULL,&nbsp;0,&nbsp; 10);</p><p style="text-indent:24px;line-height:17px;">36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="text-indent:24px;line-height:17px;">37&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="text-indent:24px;line-height:17px;">38&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;rcu_gp_lock);</p><p style="text-indent:24px;line-height:17px;">39&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">40&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">使用自由增长计数的可嵌套RCU实现</span></p><p style="text-indent:27px;">rcu_read_lock()的实现仍然十分简单。第6行将指向本线程rcu_reader_gp实例的指针放入局部变量rrgp中，将代价昂贵的访问phtread每线程变量API的数目降到最低。第7行记录rcu_reader_gp的值放入另一个局部变量tmp中，第8行检查低位字节是否为0，表明当前的rcu_read_lock()是最外层的。如果是，第9行将全局变量rcu_gp_ctr的值存入tmp，因为第7行之前存入的值可能已经过期了。如果不是，第10行增加嵌套深度，如果你能记得，它存放在计数的最低7位。第11行将更新后的计数值重新放入当前线程的rcu_reader_gp实例中，然后，也是最后，第12行执行一个内存屏障，防止RCU读端临界区泄漏到rcu_read_lock()之前的代码里。</p><p style="text-indent:27px;">换句话说，除非当前调用的rcu_read_lock()<span style="font-family:宋体;">的代码位于</span>RCU读端临界区中，否则本节实现的rcu_read_lock()原语会获取全局变量rcu_gp_ctr的一个副本，而在嵌套环境中，rcu_read_lock()则去获取rcu_reader_gp在当前线程中的实例。在两种情况下，rcu_read_lock()都会增加获取到的值，表明嵌套深度又增加了一层，然后将结果储存到当前线程的rcu_reader_gp实例中。</p><p style="text-indent:27px;">有趣的是，rcu_read_unlock()的实现和前面的实现一模一样。第19行执行一个内存屏障，防止RCU读端临界区泄漏到rcu_read_unlock()之后的代码中去，然后第20行减少当前线程的rcu_reader_gp实例，这将减少rcu_reader_gp最低几位包含的嵌套深度。rcu_read_unlock()原语的调试版本将会在减少嵌套深度之前检查rcu_reader_gp的最低几位是否为0。</p><p style="text-indent:27px;">synchronize_rcu()的实现与前面十分类似。不过存在两点不同。第一，第29行将RCU_GP_CTR_BOTTOM_BIT<span style="font-family:宋体;">增加到</span>全局变量rcu_gp_ctr，而不是直接加常数2。第二，第32行的比较被剥离成一个函数，检查RCU_GP_CTR_BOTTOM_BIT指示的位，而非无条件地检查最低位。</p><p style="text-indent:27px;">本节方法的读端性能与前面的实现几乎一样，不管CPU数目多少，开销大概为65纳秒。更新端的开销仍然较大，从Power5单核的600纳秒到64核的超过100微秒。</p><p style="text-indent:27px;">问题：为什么不像上一节那样，直接用一个单独的每线程变量来表示嵌套深度，反而用复杂的位运算来表示？</p><p style="text-indent:27px;">除了解决了RCU读端临界区嵌套问题以外，本节的实现有着和前面实现一样的缺点。另外，在32位系统上，本方法会减少全局变量rcu_gp_ctr变量溢出所需的时间。随后将介绍一种能大大延长溢出所需时间，同时又极大地降低了读端开销的方法。</p><p style="text-indent:27px;">问题：怎样才能将全局变量rcu_gp_ctr溢出的时间延长一倍？</p><p style="text-indent:27px;">问题：溢出是致命的吗？为什么？为什么不是？如果是致命的，有什么办法可以解决它？</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">9</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、基于静止状态的RCU</span></p><p style="text-indent:24px;line-height:17px;">1&nbsp;DEFINE_SPINLOCK(rcu_gp_lock);</p><p style="text-indent:24px;line-height:17px;">2&nbsp; long&nbsp; rcu_gp_ctr&nbsp;=&nbsp; 0;</p><p style="text-indent:24px;line-height:17px;">3&nbsp;DEFINE_PER_THREAD(long,&nbsp;rcu_reader_qs_gp);</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">基于quiescent-state的RCU的数据定义</span></p><p style="text-indent:27px;">下图是一种基于静止状态的用户态级RCU实现的读端原语。数据定义在上图。从图中第1至7行可以看出，rcu_read_lock()和rcu_read_unlock()原语不做任何事情，就和Linux内核一样，这种空函数会成为内联函数，然后被编译器优化掉。之所以是空函数，是因为基于静止状态的RCU实现用之前提到的静止状态来大致的作为RCU读端临界区的长度，这种状态包括第9至15行的rcu_quiescent_state()调用。进入扩展的静止状态（比如当发生阻塞时）的线程可以分别用thread_offline()和thread_online() API，来标记扩展的静止状态的开始和结尾。这样，thread_online()就成了对rcu_read_lock()的模仿，thread_offline()就成了对rcu_read_unlock()的模仿。此外，rcu_quiescent_state()<span style="letter-spacing:-.3px;">可以被认为是一个</span><span style="letter-spacing:-.3px;">rcu_thread_online()</span><span style="letter-spacing:-.3px;">紧跟一个</span><span style="letter-spacing:-.3px;">rcu_thread_offline()</span><span style="letter-spacing:-.3px;">。从RCU读端临界区中调用</span><span style="letter-spacing:-.3px;">rcu_quiescent_state()</span><span style="letter-spacing:-.3px;">、</span><span style="letter-spacing:-.3px;">rcu_thread_offline()</span><span style="letter-spacing:-.3px;">或</span><span style="letter-spacing:-.3px;">rcu_thread_online(</span>)是非法的。</p><p style="margin-top:10px;text-indent:24px;line-height:17px;">1&nbsp; static&nbsp;void&nbsp; rcu_read_lock(void)</p><p style="text-indent:24px;line-height:17px;">2&nbsp; {</p><p style="text-indent:24px;line-height:17px;">3&nbsp; }</p><p style="text-indent:24px;line-height:17px;">4</p><p style="text-indent:24px;line-height:17px;">5&nbsp; static&nbsp; void&nbsp;rcu_read_unlock(void)</p><p style="text-indent:24px;line-height:17px;">6&nbsp; {</p><p style="text-indent:24px;line-height:17px;">7&nbsp; }</p><p style="text-indent:24px;line-height:17px;">8</p><p style="text-indent:24px;line-height:17px;">9&nbsp;rcu_quiescent_state(void)</p><p style="text-indent:24px;line-height:17px;">10&nbsp; {</p><p style="text-indent:24px;line-height:17px;">11&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">12&nbsp;&nbsp;&nbsp;&nbsp;__get_thread_var(rcu_reader_qs_gp)&nbsp;=</p><p style="text-indent:24px;line-height:17px;">13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ACCESS_ONCE(rcu_gp_ctr)&nbsp; +&nbsp; 1;</p><p style="text-indent:24px;line-height:17px;">14&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">15&nbsp; }</p><p style="text-indent:24px;line-height:17px;">16</p><p style="text-indent:24px;line-height:17px;">17&nbsp; static&nbsp; void&nbsp;rcu_thread_offline(void)</p><p style="text-indent:24px;line-height:17px;">18&nbsp; {</p><p style="text-indent:24px;line-height:17px;">19&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="text-indent:24px;line-height:17px;">20&nbsp;&nbsp;&nbsp;&nbsp;__get_thread_var(rcu_reader_qs_gp)&nbsp;=</p><p style="text-indent:24px;line-height:17px;">21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ACCESS_ONCE(rcu_gp_ctr);</p><p style="text-indent:24px;line-height:17px;">22&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">23&nbsp; }</p><p style="text-indent:24px;line-height:17px;">24</p><p style="text-indent:24px;line-height:17px;">25&nbsp; static&nbsp; void&nbsp;rcu_thread_online(void)</p><p style="text-indent:24px;line-height:17px;">26&nbsp; {</p><p style="text-indent:24px;line-height:17px;">27&nbsp;&nbsp;&nbsp;&nbsp;rcu_quiescent_state();</p><p style="text-indent:24px;line-height:17px;">28&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">基于静止状态的RCU读端原语</span></p><p style="text-indent:27px;">在rcu_quiescent_state()中，第11行执行一个内存屏障，防止在静止状态之前的代码乱序到静止状态之后执行。第12至13行获取全局变量rcu_gp_ctr的副本，使用<span style="letter-spacing:-.1px;">ACCESS_ONCE()</span><span style="letter-spacing:-.1px;">来保证编译器不会启用任何优化措施让</span><span style="letter-spacing:-.1px;">rcu_gp_ctr</span><span style="letter-spacing:-.1px;">被读取超过一次。然后对取来的值加1，储存到每线程变量</span><span style="letter-spacing:-.1px;">rcu_reader_qs_gp</span><span style="letter-spacing:-.1px;">中，这样任何并发的</span><span style="letter-spacing:-.1px;">synchronize_rcu()</span>实例都只会看见奇数值，因此就知道新的RCU读端临界区开始了。正在等待老的读端临界区的synchronize_rcu()实例因此也知道忽略新产生的读端临界区。最后，第14行执行一个内存屏障，这会阻止后续代码（包括可能的RCU读端临界区）对第12至13行的重新排序。</p><p style="text-indent:27px;">问题：<span style="letter-spacing:.5px;">第14行多余的内存屏障会不会显著增加rcu_quiescent_state()的开销？</span></p><p style="text-indent:27px;">有些应用程序可能只是偶尔需要用RCU，但是一旦它们开始用，那一定是到处都在用。这种应用程序可以在开始用RCU时调用rcu_thread_online()，在不再使用RCU时调用rcu_thread_offline()。在调用rcu_thread_offline()和下一个调用rcu_thread_ online()之间的时间成为扩展的静止状态，在这段时间RCU不会显式地注册静止状态。</p><p style="text-indent:27px;">rcu_thread_offline()函数直接将每线程变量rcu_reader_qs_gp赋值为rcu_gp_ctr的当前值，该值是一个偶数。这样所有并发的synchronize_rcu()实例就知道忽略这个线程。</p><p style="text-indent:27px;">问题：为什么需要第19行和第22行的内存屏障？</p><p style="text-indent:27px;">rcu_thread_online()函数直接调用rcu_quiescent_state()，这也表示延长静止状态的结束。</p><p style="margin-top:10px;text-indent:24px;line-height:17px;">1&nbsp; void&nbsp;synchronize_rcu(void)</p><p style="text-indent:24px;line-height:17px;">2&nbsp; {</p><p style="text-indent:24px;line-height:17px;">3&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; t;</p><p style="text-indent:24px;line-height:17px;">4</p><p style="text-indent:24px;line-height:17px;">5&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="text-indent:24px;line-height:17px;">6&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;rcu_gp_lock);</p><p style="text-indent:24px;line-height:17px;">7&nbsp;&nbsp;&nbsp;&nbsp;rcu_gp_ctr&nbsp; +=&nbsp; 2;</p><p style="text-indent:24px;line-height:17px;">8&nbsp;&nbsp;&nbsp;&nbsp; smp_mb();</p><p style="text-indent:24px;line-height:17px;">9&nbsp;&nbsp;&nbsp;&nbsp;for_each_thread(t)&nbsp; {</p><p style="text-indent:24px;line-height:17px;">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp; (rcu_gp_ongoing(t)&nbsp; &amp;&amp;</p><p style="text-indent:24px;line-height:17px;">11 ((per_thread(rcu_reader_qs_gp,&nbsp; t)&nbsp; -</p><p style="text-indent:24px;line-height:17px;">12 rcu_gp_ctr)&nbsp;&lt;&nbsp; 0))&nbsp; {</p><p style="text-indent:24px;line-height:17px;">13 poll(NULL,&nbsp;0,&nbsp; 10);</p><p style="text-indent:24px;line-height:17px;">14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="text-indent:24px;line-height:17px;">15&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="text-indent:24px;line-height:17px;">16&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;rcu_gp_lock);</p><p style="text-indent:24px;line-height:17px;">17&nbsp;&nbsp;&nbsp;&nbsp;smp_mb();</p><p style="text-indent:24px;line-height:17px;">18&nbsp; }</p><p style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><span style="font-size:16px;font-family:黑体;">基于静止状态的RCU更新端原语</span></p><p style="text-indent:27px;">下图是synchronize_rcu()的实现，和前一个实现很相像。</p><p style="text-indent:27px;">本节实现的读端原语快得惊人，调用rcu_read_lock()和rcu_read_unlock()的开销一共大概50皮秒（10的负12次方秒）。synchronize_rcu()的开销从Power5单核上的600纳秒到64核上的超过100微秒不等。</p><p style="text-indent:27px;">问题：可以确定的是，ca-2008Power系统的时钟频率相当高，可是即使是5GHz的时钟频率，也不足以让读端原语在50皮秒执行完毕。这里究竟发生了什么？</p><p style="text-indent:27px;">不过，本节的实现要求每个线程要么周期性地调用rcu_quiescent_state()，要么为扩展的静止状态调用rcu_thread_offline()。周期性调用这些函数的要求在某些情况下会让实现变得困难，比如某种类型的库函数。</p><p style="text-indent:27px;">另外，本节的实现不允许并发的synchronize_rcu()调用来共享同一个优雅周期。不过，完全可以基于这个RCU版本写一个产品级的RCU实现。</p><p style="margin-top:8px;margin-bottom:4px;"><span style="font-size:16px;line-height:115%;font-family:黑体;">10</span><span style="font-size:16px;line-height:115%;font-family:黑体;">、关于玩具式RCU实现的总结</span></p><p style="text-indent:27px;">如果你看到这里，恭喜！你现在不仅对RCU本身有了更清晰的了解，而且对其所需要的软件和应用环境也更熟悉了。想要更进一步了解RCU的读者，请自行阅读在各种产品中大量采用的RCU实现。</p><p style="text-indent:27px;">之前的章节列出了各种RCU原语的理想特性。下面我们将整理一个列表，供有意实现自己的RCU实现的读者做参考。</p><p style="text-indent:27px;">1．必须有读端原语（比如rcu_read_lock()和rcu_read_unlock()）和优雅周期原语（比如synchronize_rcu()和call_rcu()），任何在优雅周期开始前就存在的RCU读端临界区必须在优雅周期结束前执行完毕。</p><p style="text-indent:27px;">2．RCU读端原语应该有最小的开销。特别是应该避免如高速缓存未命中、原子操作、内存屏障和条件分支之类的操作。</p><p style="text-indent:27px;">3．RCU读端原语应该有O(1)的时间复杂度，可以用于实时用途。（这意味着读者可以与更新者并发运行。）</p><p style="text-indent:27px;">4．RCU读端原语应该在所有上下文中都可以使用（在Linux内核中，只有空的死循环时不能使用RCU读端原语）。一个重要的特例是RCU读端原语必须可以在RCU读端临界区中使用，换句话说，必须允许RCU读端临界区嵌套。</p><p style="text-indent:27px;">5．RCU读端原语不应该有条件判断，不会返回失败。这个特性十分重要，因为错误检查会增加复杂度，让测试和验证变得更复杂。</p><p style="text-indent:27px;">6．除了静止状态以外的任何操作都能在RCU读端原语里执行。比如像I/O这样的操作也该允许。</p><p style="text-indent:27px;">7．应该允许在RCU读端临界区中执行的同时更新一个受RCU保护的数据结构。</p><p style="text-indent:27px;">8．RCU读端和更新端的原语应该在内存分配器的设计和实现上独立。</p><p style="text-indent:27px;">9．RCU优雅周期不应该被在RCU读端临界区之外阻塞的线程而阻塞。</p><p style="margin-right:16px;text-align:justify;text-justify:inter-ideograph;text-indent:0;line-height:125%;"><strong>&nbsp;</strong></p><p style="margin-right:16px;text-align:justify;text-justify:inter-ideograph;line-height:125%;"><strong>所有这些目标，都被</strong><strong>Linux</strong><strong>内核</strong><strong>RCU</strong><strong>实现所满足。后续将分析</strong><strong>Linux</strong><strong>内核中</strong><strong>RCU</strong><strong>实现代码。</strong></p><p><span style="font-size: 12px;"></span><br  /></p><p><strong><span style="color: rgb(0, 209, 0);">近期精彩文章</span></strong></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652663527&amp;idx=1&amp;sn=5686505c73273ed0449e2340e8999b81&amp;chksm=810f287ab678a16c5ecb88bde52e401f7df02425148b6e318e8178b7c0de0be8db30ee1faf84&amp;scene=21#wechat_redirect" target="_blank">宋宝华： 关于DMA ZONE和dma alloc coherent若干误解的彻底澄清</a><br  /></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652663542&amp;idx=1&amp;sn=1e19be71d650eba288b0341d09e164df&amp;chksm=810f286bb678a17d06b4659d00717517f3f65ab8a6452a33e799b6010b00814895647bc188d7&amp;scene=21#wechat_redirect" target="_blank">宋宝华：关于Ftrace的一个完整案例</a><br  /></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652663555&amp;idx=1&amp;sn=955eb4eec1c1587152ca05235eaf93ea&amp;chksm=810f299eb678a08817411e0f940c1810616cc1471fedf4a54dabd127751db3b1d55f5a7f5c9e&amp;scene=21#wechat_redirect" target="_blank">宋宝华：swappiness=0究竟意味着什么？</a><br  /></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_reward_area" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_reward_avatar">
                        <img src="" alt="" id="js_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" style="display: none;" id="js_reward_author">谢宝友</div>
                                                            <p class="reward_tips js_reward_wording">给谢老师疯狂打call</p>
                                        <p class="reward_button_wrp">
                      <span id="js_author_reward_qrcode" class="reward_pop_panel">
                        <img id="js_author_reward_qrcode_img" src="" alt="赞赏二维码">
                        <strong>微信扫一扫赞赏作者</strong>
                      </span>
                        <a class="reward_button" id='js_reward_link' href="##"><span id="js_reward_link_text">赞赏</span></a>
                    </p>
                    <div id="js_reward_inner" class="reward_area_inner" style="display:none;">
                        <p class="weui-loadmore weui-loadmore_line reward_user_tips" id="js_reward_total_parent">
                          <span class="weui-loadmore__tips">
                            <a href="javascript:;" id="js_reward_total"></a>&nbsp;<span id="js_reward_total_text">人赞赏</span>
                        </span>
                        </p>
                        
                        <div id="js_reward_list" class="reward_user_list"></div>
                        <div id="js_reward_pagination" class="simple_pagination" style="display: none;">
                          <button disabled class="btn_sp_prev js_reward_pagination_prev">上一页</button>
                          <span class="sp_page_num_area">
                            <a class="sp_page_current js_reward_pagination_curpage" href="javascript:;">1</a>&#47;<span class="sp_page_num js_reward_pagination_totalpage">3</span>
                          </span>
                          <button class="btn_sp_next js_reward_pagination_next">下一页</button>
                        </div>
                    </div>
                </div>
                                <div class="reward_qrcode_area reward_area tc" id="js_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                                        <p class="reward_tips">给谢老师疯狂打call</p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" id="js_reward_qrcode_img"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='https://www.52pojie.cn/' target='_blank'>
			吾爱破解论坛
		</a>
	</div>
</body>